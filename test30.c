#include<stdio.h>
#include<string.h>

#include"tools.h"

//#define TEST_MD4

void test_md4()  {
  unsigned char digest[16];

  //MD4 ("") = 31d6cfe0d16ae931b73c59d7e0c089c0
  md4("", 0, digest);
  hexdump(digest, 16);

  //MD4 ("a") = bde52cb31de33e46245e05fbdbd6fb24
  md4("a", 1, digest);
  hexdump(digest, 16);
  
  //MD4 ("abc") = a448017aaf21d8525fc10ae87aa6729d
  md4("abc", 3, digest);
  hexdump(digest, 16);

}

unsigned char secret_key[128];
int secret_key_len = 0;

void init_key() {
  unsigned char binkey[64];
  random_bytes((unsigned char *)&secret_key_len, sizeof(secret_key_len));
  secret_key_len &= 0x7fffffff;
  secret_key_len = (16 + secret_key_len % 16);
  
  random_bytes(binkey, secret_key_len);
  // secret_key is null terminated
  hexencode(binkey, secret_key_len, secret_key);
  //  printf("key_len: %d\n", secret_key_len);
  //printf("%s\n", secret_key);
}

int main(int argc, char *argv[]) {
  unsigned char mac[16];
  char buff[128];
  unsigned char tamp[2048];
  const char *data = "comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon";

#ifdef TEST_MD4
  test_md4();
#else
  init_key();

  generate_mac(MD4, data, strlen(data), secret_key, secret_key_len, mac);
  hexencode(mac, 16, buff);
  buff[32] = '\0';
  printf("digest: %s\n", buff);
  printf("mac valid: %d\n", validate_mac(MD4, data, strlen(data), secret_key, secret_key_len, mac));
  strcpy(tamp, data);
  strcat(tamp, ";admin=true");
  printf("tampered msg mac valid: %d\n", validate_mac(MD4, tamp, strlen(tamp), secret_key, secret_key_len, mac));

  // now try to bruteforce a valid message by continuing the existing mac.
  //
  // valid mac is based on sha1(key || msg) which is generated by sha1_update(key || msg || padding0)

  // we want sha1(key || msg || padding0 || tampering || padding1) to be valid, 
  // for that we need to guess key length and append tampering and continue
  // the sha1 hash function over padding and tampering.

  // padding = | 0x80 0000 ... 0000 LEN | where 
  // 

  // tampered mac

  unsigned char tampmac[16];

  int msglen = strlen(data);
  int keylen = 0; // start with a zero length key  
  int valid;

  do {
    
    // the sha1 state we will continue on
    //
    //                      h[4]
    //                       |              
    // key || msg || padding0
    //
    
    unsigned int h[4];
    int i;
    for(i = 0; i < 4; i++) {
      h[i] = *(unsigned int *)(mac +  4*i);
    } 

    strcpy(tamp, ";admin=true");

    int key_data_padding0_len =  ((keylen + msglen + 9) + 64 - (keylen + msglen + 9) % 64);
    int tamp_len = strlen(tamp);

    // the length of the tampered message, that is msglen + keylen + padding + tamp

    // calculate tampered mac

    // the sha1 state we will continue on
    //
    //                       h[4]  ---->      tamp_mac
    //                         |                |
    // key || msg || padding0 || tamp || padding1
    //


    md4_finish(tamp, key_data_padding0_len + tamp_len, h, tampmac);

    //printf("tampered mac:\n");
    //hexdump(tampmac, 20);
  
    // generate tampered the message, that is, original message + padding0 + tampered data
    strcpy(tamp, data);

    // append padding0 after original message
    //
    // length of padding0 is (key+msg+9+64) - (key+msg+9+64) % 64
  
    unsigned char *p = tamp+strlen(tamp);

    *p++ = 0x80;
    // nullpadd until 8 bytes from block boundary
    while( (keylen + (p - (unsigned char *)tamp) ) % 64 != 56) {
      *p++ = 0;
    }


    unsigned int bits = 8*(msglen + keylen);
    // append the 32 bit length field
    *p++ = bits & 0xff;
    *p++ = bits >> 8;
    *p++ = bits >> 16;
    *p++ = bits >> 24;

    // last  32 bits of 64 bit length indicator is zero
    *p++ = 0;
    *p++ = 0;
    *p++ = 0;
    *p++ = 0;
  



    // append tampering
    strcpy(p, ";admin=true");
    p += strlen(p);

    int tampered_msg_len = p - tamp;

    //printf("Validate mac using length: %d\n", tampered_msg_len);
    //hexdump(tamp, tampered_msg_len);

    valid = validate_mac(MD4, tamp, tampered_msg_len, secret_key, secret_key_len, tampmac);

    if(!valid) {
      keylen++;
      printf("Message not accepted, try larger keylength %d\n", keylen);
    } else {
      printf("tampered message accepted, guessed keylength: %d\n", keylen);
    }

  } while(!valid && keylen < 33);  


  if(!valid) {
    printf("Failed to get tampered message accepted\n");
  }
#endif
  return 0;

}
